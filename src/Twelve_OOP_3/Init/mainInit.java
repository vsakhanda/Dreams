package Twelve_OOP_3.Init;

public class mainInit {

/*
    Поля (fields) : переменные, объявленные в классе;
    Локальные переменные (local variables) : переменные в методе или в блоке кода;
    Параметры (parameters) : переменные в объявлении метода (в сигнатуре).


    Все переменные должны иметь тип переменной и название переменной.
Тип переменной показывает, какие данные представляет данная переменная (т.е. какие данные может хранить). Как мы знаем, тип переменной может быть примитивным (primitives primitives) или объектным, не примитивными (Non-primitive). При объектных переменных их тип описывается определённым классом.
Название переменной должно быть с маленькой буквы, в camel case. Подробнее про именование можно прочитать в "Variables:Naming".


 If your variable stores a constant value, such as static final int NUM_GEARS = 6, the convention changes slightly, capitalizing every letter and separating subsequent words with the underscore character. By convention, the underscore character is never used elsewhere.

 Инициализация переменной – присвоение переменной значения.

*/

    private static int Number; // Статична змінна, до якої треба звертатись - збереження виконується в stack.
    /*
        Инициализация полей, указанных в классе происходит особым образом в зависимости от того, является ли поле статическим или нет. Если у поля стоит ключевое слово static, то данное поле относится к самому классу, а не слово static не указано, то данное поле относится к экземпляру класса.
    */
    private int NumberInt;
    //Змінна класу - вже не примітивний тип даних і збереження виконується в Heap
    /* Давайте ещё раз рассуждать. JVM узнает о том, откуда ей выполнять программу, т.е. она видит main метод. Она создаёт поток, под него выделяет память (потоку ведь надо где-то хранить данные, которые нужны для выполнения). В этом потоке выделяется фрэйм под метод main. Далее мы создаём объект HelloWorld. Этот объект уже создаётся не в стэке, а в хипе. Потому что object у нас не примитивный тип, а объектный. А в стэке будет храниться только ссылка на объект в хипе (мы ведь как-то должны обращаться к этому объекту). Далее в стэке метода main будут выделены фрэймы для выполнения метода println. После выполнения метода main будут уничтожены все фрэймы. При уничтожении фрэйма будут уничтожены все данные. Объект object не будет уничтожен сразу. Сначала на него будет уничтожена ссылка и таким образом на объект object больше никто ссылаться не будет и доступа больше к этому объекту в памяти будет не получить. Умная JVM имеет свой механизм для такого – сборщик мусора (garbage collector или сокращённо GC). Он то и удаляет из памяти такие объекты, на которые больше никто не ссылается.
    * */




    private static int a = 11212;
    private static int b =a ;


// Послідовність ініціалізації має значення, оскільки запис змінних виконується в пам'ять, то врахоується послідовність декларація змінних.
    // при послідовносіт b, a   - буде помилка "java: illegal forward reference" , а при послідовності a, b  - такої помилки не виникає


    static {
        System.out.println("Static block" + a);
    }

    {
        System.out.println("Block");
    }

    public mainInit () {
        System.out.println("Constructor");
    }


    public static void main(String[] args) {

        int object1 = 7;
        mainInit variable = new mainInit();
//        Number = 12;
        System.out.println(object1 * Number + " " + variable.NumberInt);
        System.out.println(b);



    }
}
